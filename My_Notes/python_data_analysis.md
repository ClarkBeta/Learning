# Python 数据分析
根据《利用 Python 进行数据分析 · 第 2 版》整理
## 1.准备工作
### 1.1 本书导航
尽管读者各自的工作任务不同，大体可以分为几类：

- 与外部世界交互

阅读编写多种文件格式和数据存储；

- 数据准备

清洗、修改、结合、标准化、重塑、切片、切割、转换数据，以进行分析；

- 转换数据

对旧的数据集进行数学和统计操作，生成新的数据集（例如，通过各组变量聚类成大的表）；

- 建模和计算

将数据绑定统计模型、机器学习算法、或其他计算工具；

- 展示

创建交互式和静态的图表可视化和文本总结。
### 引入惯例
```python
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import statsmodels as sm
```
### 行话
数据规整（Munge/Munging/Wrangling） 指的是将非结构化和（或）散乱数据处理为结构化或整洁形式的整个过程。这几个词已经悄悄成为当今数据黑客们的行话了。Munge这个词跟Lunge押韵。

伪码（Pseudocode） 算法或过程的“代码式”描述，而这些代码本身并不是实际有效的源代码。

语法糖（Syntactic sugar） 这是一种编程语法，它并不会带来新的特性，但却能使代码更易读、更易写。
## 2.NumPy 基础：数组和矢量计算
### 2.1 NumPy的ndarray：一种多维数组对象
#### 创建ndarray
```python
import numpy as np
data1 = [6, 7.5, 8, 0, 1]
arr1=np.array(data1)
arr1 # Output: [6.  7.5 8.  0.  1. ]

# 嵌套序列（比如由一组等长列表组成的列表）将会被转换为一个多维数组
data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
arr2 = np.array(data2)
arr2 # Output: array([[1, 2, 3, 4],
     #                [5, 6, 7, 8]])

#因为data2是列表的列表，NumPy数组arr2的两个维度的shape是从data2引入的。可以用属性ndim和shape验证
arr2.ndim # Output: 2
arr2.shape # Output: (2, 4)

#除非特别说明（稍后将会详细介绍），np.array会尝试为新建的这个数组推断出一个较为合适的数据类型。数据类型保存在一个特殊的dtype对象中。
arr1.dtype # Output: dtype('float64')
arr2.dtype # Output: dtype('int32')

np.zeros(10) # Output: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
np.zeros((3, 6))
# array([[ 0.,  0.,  0.,  0.,  0.,  0.],
#        [ 0.,  0.,  0.,  0.,  0.,  0.],
#        [ 0.,  0.,  0.,  0.,  0.,  0.]])
np.empty((2, 3, 2))
# array([[[ 0.,  0.],
#         [ 0.,  0.],
#         [ 0.,  0.]],
#        [[ 0.,  0.],
#         [ 0.,  0.],
#         [ 0.,  0.]]])
# 注意：认为np.empty会返回全0数组的想法是不安全的。很多情况下（如前所示），它返回的都是一些未初始化的垃圾值。

np.arange(15) # Output: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
```
#### ndarray的数据类型
dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息

dtype是NumPy灵活交互其它系统的源泉之一。多数情况下，它们直接映射到相应的机器表示，这使得“读写磁盘上的二进制数据流”以及“集成低级语言代码（如C、Fortran）”等工作变得更加简单。数值型dtype的命名方式相同：一个类型名（如float或int），后面跟一个用于表示各元素位长的数字。标准的双精度浮点值（即Python中的float对象）需要占用8字节（即64位）。因此，该类型在NumPy中就记作float64。

```python
import numpy as np
# 你可以通过ndarray的astype方法明确地将一个数组从一个dtype转换成另一个dtype
arr = np.array([1, 2, 3, 4, 5])
arr.dtype # Output: dtype('float64')
float_arr = arr.astype(np.float64)
float_arr # Output: array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])
float_arr.dtype # Output: dtype('float64')

# 注意：使用numpy.string_类型时，一定要小心，因为NumPy的字符串数据是大小固定的，发生截取时，不会发出警告。pandas提供了更多非数值数据的便利的处理方法。
# 调用astype总会创建一个新的数组（一个数据的备份），即使新的dtype与旧的dtype相同。
```
#### NumPy数组的运算
```python
#数组很重要，因为它使你不用编写循环即可对数据执行批量运算。NumPy用户称其为矢量化（vectorization）。大小相等的数组之间的任何算术运算都会将运算应用到元素级
In [1]: import numpy as np

In [2]: arr=np.array([[1.,2.,3.],[4.,5.,6.]])

In [3]: arr
Out[3]:
array([[1., 2., 3.],
       [4., 5., 6.]])

In [4]: arr+arr
Out[4]:
array([[ 2.,  4.,  6.],
       [ 8., 10., 12.]])

In [5]: arr-arr
Out[5]:
array([[0., 0., 0.],
       [0., 0., 0.]])

In [6]: arr**2
Out[6]:
array([[ 1.,  4.,  9.],
       [16., 25., 36.]])

In [7]: arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])

In [8]: arr2
Out[8]:
array([[ 0.,  4.,  1.],
       [ 7.,  2., 12.]])

In [9]: arr2>arr
Out[9]:
array([[False,  True, False],
       [ True, False,  True]])
#不同大小的数组之间的运算叫做广播（broadcasting）
```
#### 基本的索引和切片
```python
In [1]: import numpy as np

In [2]: arr=np.arange(10)

In [3]: arr
Out[3]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [4]: arr[5]
Out[4]: 5

In [5]: arr[5:8]
Out[5]: array([5, 6, 7])

In [6]: arr[5:8] = 12
#如上所示，当你将一个标量值赋值给一个切片时（如arr[5:8]=12），该值会自动传播（也就说后面将会讲到的“广播”）到整个选区。跟列表最重要的区别在于，数组切片是原始数组的视图。这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。
In [7]: arr
Out[7]: array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])

In [8]: arr_slice=arr[5:8]

In [9]: arr_slice
Out[9]: array([12, 12, 12])

In [10]: arr_slice[1]=12345

In [11]: arr
Out[11]:
array([    0,     1,     2,     3,     4,    12, 12345,    12,     8,
           9])

In [12]: arr_slice[:]=64

In [13]: arr
Out[13]: array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])
#如果你想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作，例如arr[5:8].copy()。
In [14]: arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

In [15]: arr2d
Out[15]:
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])

In [16]: arr2d[0][2]
Out[16]: 3

In [17]: arr2d[0,2]
Out[17]: 3

In [18]: arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])

In [19]: arr3d[0]
Out[19]:
array([[1, 2, 3],
       [4, 5, 6]])
```
#### 切片索引
```python

In [22]: arr
Out[22]: array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])

In [23]: arr[1:6]
Out[23]: array([ 1,  2,  3,  4, 64])

In [24]: arr2d
Out[24]:
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])

In [25]: arr2d[0:2]
Out[25]:
array([[1, 2, 3],
       [4, 5, 6]])

In [26]: arr2d[:2,1:]
Out[26]:
array([[2, 3],
       [5, 6]])

In [27]: arr2d[:,:1]
Out[27]:
array([[1],
       [4],
       [7]])

In [28]: arr2d[:2, 1:] = 0

In [29]: arr2d
Out[29]:
array([[1, 0, 0],
       [4, 0, 0],
       [7, 8, 9]])
```
#### 布尔型索引
```python

In [3]: import numpy as np

In [4]: names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])

In [5]: data=np.random.randn(7,4)

In [6]: names
Out[6]: array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='<U4')

In [7]: data
Out[7]:
array([[-0.04342017, -0.17829974,  1.29186035, -0.85096499],
       [-0.72379008,  1.45825777,  0.74882251,  0.22158459],
       [ 0.22654587,  0.86119875, -0.69631007,  1.21711047],
       [ 0.73963991, -0.85416688, -0.0034054 , -0.46502233],
       [-1.2950635 ,  0.75802453, -2.76714624, -0.99236344],
       [ 1.47419952,  0.64780725,  0.10079612,  0.11044368],
       [ 0.48035293,  0.06239147, -0.51771029,  0.30601005]])

In [8]: names=='Bob'
Out[8]: array([ True, False, False,  True, False, False, False])

In [10]: data[names=='Bob']
Out[10]:
array([[-0.04342017, -0.17829974,  1.29186035, -0.85096499],
       [ 0.73963991, -0.85416688, -0.0034054 , -0.46502233]])

In [11]: data[names=='Bob',2:]
Out[11]:
array([[ 1.29186035, -0.85096499],
       [-0.0034054 , -0.46502233]])

In [12]: data[names!='Bob']
Out[12]:
array([[-0.72379008,  1.45825777,  0.74882251,  0.22158459],
       [ 0.22654587,  0.86119875, -0.69631007,  1.21711047],
       [-1.2950635 ,  0.75802453, -2.76714624, -0.99236344],
       [ 1.47419952,  0.64780725,  0.10079612,  0.11044368],
       [ 0.48035293,  0.06239147, -0.51771029,  0.30601005]])

In [13]: data[~(names=='Bob')]
Out[13]:
array([[-0.72379008,  1.45825777,  0.74882251,  0.22158459],
       [ 0.22654587,  0.86119875, -0.69631007,  1.21711047],
       [-1.2950635 ,  0.75802453, -2.76714624, -0.99236344],
       [ 1.47419952,  0.64780725,  0.10079612,  0.11044368],
       [ 0.48035293,  0.06239147, -0.51771029,  0.30601005]])

In [14]: mask = (names == 'Bob') | (names == 'Will')

In [15]: mask
Out[15]: array([ True, False,  True,  True,  True, False, False])

In [16]: data[mask]
Out[16]:
array([[-0.04342017, -0.17829974,  1.29186035, -0.85096499],
       [ 0.22654587,  0.86119875, -0.69631007,  1.21711047],
       [ 0.73963991, -0.85416688, -0.0034054 , -0.46502233],
       [-1.2950635 ,  0.75802453, -2.76714624, -0.99236344]])

In [17]: data[data < 0] = 0

In [18]: data
Out[18]:
array([[0.        , 0.        , 1.29186035, 0.        ],
       [0.        , 1.45825777, 0.74882251, 0.22158459],
       [0.22654587, 0.86119875, 0.        , 1.21711047],
       [0.73963991, 0.        , 0.        , 0.        ],
       [0.        , 0.75802453, 0.        , 0.        ],
       [1.47419952, 0.64780725, 0.10079612, 0.11044368],
       [0.48035293, 0.06239147, 0.        , 0.30601005]])

In [19]:
```
#### 花式索引
```python

In [20]: arr = np.empty((8, 4))

In [21]: arr
Out[21]:
array([[0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.]])

In [22]: for i in range(8):
    ...:     arr[i]=i
    ...:

In [23]: arr
Out[23]:
array([[0., 0., 0., 0.],
       [1., 1., 1., 1.],
       [2., 2., 2., 2.],
       [3., 3., 3., 3.],
       [4., 4., 4., 4.],
       [5., 5., 5., 5.],
       [6., 6., 6., 6.],
       [7., 7., 7., 7.]])

In [24]: arr[[4,3,0,6]]
Out[24]:
array([[4., 4., 4., 4.],
       [3., 3., 3., 3.],
       [0., 0., 0., 0.],
       [6., 6., 6., 6.]])

In [26]: arr[[-3,-5,-7]]
Out[26]:
array([[5., 5., 5., 5.],
       [3., 3., 3., 3.],
       [1., 1., 1., 1.]])

In [27]: arr = np.arange(32).reshape((8, 4))

In [28]: arr
Out[28]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])

In [29]: arr[[1, 5, 7, 2], [0, 3, 1, 2]]
Out[29]: array([ 4, 23, 29, 10])

In [30]: arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]
Out[30]:
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])
```
#### 数组转置和轴对换
```python

In [32]: arr = np.arange(15).reshape((3, 5))

In [33]: arr
Out[33]:
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])

In [34]: arr.T
Out[34]:
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])

In [35]: arr = np.random.randn(6, 3)

In [36]: np.dot(arr.T,arr)
Out[36]:
array([[ 1.35176473, -1.2575253 ,  0.28713411],
       [-1.2575253 ,  5.788405  , -1.45505948],
       [ 0.28713411, -1.45505948,  2.75947431]])

In [37]: arr
Out[37]:
array([[ 1.01222193, -0.75537997,  0.17833869],
       [ 0.00450704, -0.31817327,  1.15575677],
       [-0.24040737,  1.75135059, -0.91797894],
       [-0.122436  ,  1.32667231,  0.64239593],
       [ 0.49469482,  0.08039478, -0.00880666],
       [ 0.09819335,  0.53180847, -0.36940558]])

In [38]: arr = np.arange(16).reshape((2, 2, 4))

In [39]: arr
Out[39]:
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])

In [40]: arr.transpose((1, 0, 2))
Out[40]:
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])

In [41]: arr.swapaxes(1, 2)
Out[41]:
array([[[ 0,  4],
        [ 1,  5],
        [ 2,  6],
        [ 3,  7]],

       [[ 8, 12],
        [ 9, 13],
        [10, 14],
        [11, 15]]])

In [42]:
```
### 2.2 通用函数：快速的元素级数组函数
```python

In [43]: arr = np.arange(10)

In [44]: arr
Out[44]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [45]: np.sqrt(arr)
Out[45]:
array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])

In [46]: np.exp(arr)
Out[46]:
array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,
       5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,
       2.98095799e+03, 8.10308393e+03])

In [47]: x = np.random.randn(8)

In [48]: y = np.random.randn(8)

In [49]: x
Out[49]:
array([ 1.13452998,  0.81575267,  1.26180146,  0.24220166, -0.14617712,
        0.27809825,  1.38040457,  0.29749095])

In [50]: y
Out[50]:
array([ 0.4769148 , -0.04637992,  1.5971585 , -1.19317644, -0.31066555,
       -0.44274564, -0.70730456,  0.68088096])

In [51]: np.maximum(x, y)
Out[51]:
array([ 1.13452998,  0.81575267,  1.5971585 ,  0.24220166, -0.14617712,
        0.27809825,  1.38040457,  0.68088096])

In [52]: arr = np.random.randn(7) * 5

In [53]: arr
Out[53]:
array([ 0.36055961,  8.70781927, -1.83310484, -4.71154144, -4.16036345,
       -1.7877426 ,  4.48132431])

In [54]: remainder, whole_part = np.modf(arr)

In [55]: remainder
Out[55]:
array([ 0.36055961,  0.70781927, -0.83310484, -0.71154144, -0.16036345,
       -0.7877426 ,  0.48132431])

In [56]: whole_part
Out[56]: array([ 0.,  8., -1., -4., -4., -1.,  4.])

In [57]:
```

**一元 ufunc（单输入）**

这些函数对数组的每个元素进行操作：

1. **数学运算**
   - `np.abs(x)` - 绝对值
   - `np.sqrt(x)` - 平方根
   - `np.square(x)` - 平方
   - `np.exp(x)` - 指数（\(e^x\)）
   - `np.log(x)`、`np.log10(x)`、`np.log2(x)` - 自然对数、常用对数、以2为底的对数
   - `np.sign(x)` - 符号函数（返回 -1, 0, 或 1）

2. **三角函数**
   - `np.sin(x)`、`np.cos(x)`、`np.tan(x)`
   - `np.arcsin(x)`、`np.arccos(x)`、`np.arctan(x)`
   - `np.deg2rad(x)` - 度转弧度
   - `np.rad2deg(x)` - 弧度转度

3. **舍入和近似**
   - `np.ceil(x)` - 向上取整
   - `np.floor(x)` - 向下取整
   - `np.trunc(x)` - 截断小数部分
   - `np.round(x)` - 四舍五入

4. **其他**
   - `np.isnan(x)` - 检查是否为 `NaN`
   - `np.isfinite(x)` - 检查是否有限
   - `np.isinf(x)` - 检查是否为无穷大



**二元 ufunc（双输入）**

这些函数对两个数组的对应元素进行操作：

1. **算术运算**
   - `np.add(x, y)` - 加法（等效于 `x + y`）
   - `np.subtract(x, y)` - 减法（`x - y`）
   - `np.multiply(x, y)` - 乘法（`x * y`）
   - `np.divide(x, y)` - 除法（`x / y`）
   - `np.floor_divide(x, y)` - 向下取整除法（`x // y`）
   - `np.power(x, y)` - 幂运算（`x ** y`）
   - `np.mod(x, y)` - 取模（`x % y`）

2. **比较运算**
   - `np.equal(x, y)` - 等于（`x == y`）
   - `np.not_equal(x, y)` - 不等于（`x != y`）
   - `np.greater(x, y)` - 大于（`x > y`）
   - `np.greater_equal(x, y)` - 大于等于（`x >= y`）
   - `np.less(x, y)` - 小于（`x < y`）
   - `np.less_equal(x, y)` - 小于等于（`x <= y`）

3. **逻辑运算**
   - `np.logical_and(x, y)` - 逻辑与（`x & y`）
   - `np.logical_or(x, y)` - 逻辑或（`x | y`）
   - `np.logical_xor(x, y)` - 逻辑异或
   - `np.maximum(x, y)` - 逐元素最大值
   - `np.minimum(x, y)` - 逐元素最小值

4. **特殊函数**
   - `np.copysign(x, y)` - 将 `y` 的符号复制到 `x`
   - `np.ldexp(x, y)` - \(x \times 2^y\)（浮点数缩放）


### 2.3 利用数组进行数据处理
